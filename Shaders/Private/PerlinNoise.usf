#include "/Engine/Public/Platform.ush"
//#pragma kernel Diffuse

//RWStructuredBuffer<float> noiseValues;
RWTexture2D<float4> noisemap;
float2 start;
int2 dimensions;
float offset;

float2 hash( float2 p ) // replace this by something better
{
	p = float2( dot(p,float2(127.1,311.7)), dot(p,float2(269.5,183.3)) );
	return -1.0 + 2.0*frac(sin(p)*43758.5453123);
}

float noise( float2 p )
{
    const float K1 = 0.366025404; // (sqrt(3)-1)/2;
    const float K2 = 0.211324865; // (3-sqrt(3))/6;

	float2  i = floor( p + (p.x+p.y)*K1 );
    float2  a = p - i + (i.x+i.y)*K2;
    float m = step(a.y,a.x); 
    float2  o = float2(m,1.0-m);
    float2  b = a - o + K2;
	float2  c = a - 1.0 + 2.0*K2;
    float3  h = max( 0.5-float3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
	float3  n = h*h*h*h*float3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
    return dot( n, float3(70.0,70.0,70.0) );
}

float4 mainImage(float2 position )
{
    float2 p = position.xy / dimensions.xy;

	float2 uv = p*float2(dimensions.x/dimensions.y,1.0);
	
	uv *= 5.0f;
	float2x2 m = float2x2( 1.6,  1.2, -1.2,  1.6 );
	float f  = 0.5000f*noise( uv );
	//uv = m*uv;
	f += 0.2500f*noise( uv );
	//uv = m*uv;
	f += 0.1250f*noise( uv );
	//uv = m*uv;
	f += 0.0625f*noise( uv );
	//uv = m*uv;

	f = 0.5f + 0.5f*f;
	
    f *= smoothstep( 0.0, 0.005, abs(p.x-0.6) );	
	
	return float4( f, f, f, 1.0 );
}

[numthreads(8,8,8)]
void GenerateNoise (uint3 id : SV_DispatchThreadID)
{
	if (id.x < 0 || id.x >= (uint)dimensions.x || id.y < 0 || id.y >= (uint)dimensions.y) {
		return;
	}

	float x = start.x + id.x * offset;
	float y = start.y + id.y * offset;
	float4 val = mainImage(float2(x,y));
	noisemap[id.xy] = val;
}



